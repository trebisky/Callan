#! /usr/bin/python3

# hexfix
#  Tom Trebisky  1-22-2022 2-18-2022
#
# clean up various unpleasant issues in the disassembly
# generated by objdump.
# As an incidental benefit, we get rid of some trailing whitespace.
#
# more importantly, we convert a bunch of constants that are
# displayed in decimal to good old hex.
#
# We look for a # followed by a digit or - sign
# interestingly we never see #0x
#

import re

infile = "callan13.dis"

# split on #, then on ,
def process ( thing ) :
    t = thing.split("#")
    tt = t[1].split(',')

    ival = int(tt[0])
    h = hex(ival)

    # strip silly leading "-"
    if h[0] == '-' :
        h = h[1:]

    #print ( tt[0] )
    #print ( h )

    return t[0] + "#" + h + "," + tt[1]
    #return t[0] + "#" + tt[0] + "," + tt[1]

# When developing we return None
def debug ( l ) :
    #return None
    return l

def scan ( line ) :
    if line.startswith(";") :
        return debug ( line )

    # linkw had decimal constants, but we don't mind
    # in that case.  And they are at the end of the
    # line as in:  linkw %fp,#-4
    if "linkw" in line :
        return debug ( line )

    # Python is happy either way.
    #if not ", [" in line :
    if "#" not in line :
        return debug ( line )

    # lines have 3 sections split up by tabs
    # the address, the hex, the disassembly
    # we only want to work on the last of these
    lt = line.split('\t')
    if len(lt) != 3 :
        return debug ( line )

    # it turns out that every thing with a #constant is
    # followed by a comma, the only case with
    # an immediate at the end is linkw and we
    # already return with that.
    #x = re.search ( "#.*,", lt[2] )
    #if ( x != None ) :
    #    return None

    lt[2] = process ( lt[2] )

    return "\t".join(lt)

with open ( infile ) as f:
    for line in f:
        fix = scan ( line.rstrip() )
        if fix != None :
            print ( fix )

